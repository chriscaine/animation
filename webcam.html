<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta charset="utf-8" />
    <link href="bootstrap.css" rel="stylesheet" />
    <style type="text/css">
        body {
            background-color: #222;
        }

        #monitor {
            position: relative;
            width: 400px;
            height: 300px;
            padding: 0;
            margin: 0;
        }

            #monitor video {
                position: absolute;
                top: 0;
                left: 0;
                z-index: 10;
                opacity: 1;
                transition: opacity .1s linear;
            }

                #monitor video:hover {
                    opacity: .5;
                }

            #monitor img {
                position: absolute;
                top: 0;
                left: 0;
                z-index: 5;
            }

        #export-link[href^="#"] {
            display: none;
        }
    </style>
</head>
<body>

    <div class="container-fluid" style="margin-top: 10px;">
        <div class="row-fluid">
            <div class="col-xs-5">
                <div id="monitor" style="margin:auto;">
                    <img id="image" width="400" height="300" />
                    <video autoplay width="400" height="300" id="video"></video>
                </div>
                <div style="display:flex;  justify-content:space-around; margin-top:10px; height:100px;">
                    <button class="btn btn-primary btn-lg" id="btn-shutter">Capture Frame</button>
                    <button class="btn btn-default btn-lg" id="btn-export">Render Video</button>

                </div>

            </div>
            <div class="col-xs-7">
                <div style="position:relative; width: 400px; height:300px;">
                    <div style="margin:auto; width:400px; height:300px; background: #e5e5e5; z-index:1; position:absolute; display:flex; flex-direction:column; border-radius:4px; align-items:center; justify-content:center;">
                        <h1>How to use...</h1>
                        <ol>
                            <li>Agree to use webcam</li>
                            <li>Line up you first frame with your webcam</li>
                            <li>Press Capture Frame</li>
                            <li>Your animation will be previewed here</li>
                            <li>When it is complete press the Render Video button</li>
                            <li>Your animation will play once and then your video will appear</li>
                            <li>Click Save As to save your video to the computer</li>
                        </ol>
                    </div>
                    <canvas id="previewCanvas" width="640" height="480" style="background-color:transparent; margin:auto; width:400px; height:300px; position:absolute; z-index:10;"></canvas>
                </div>
                <div class="alert alert-info" style="width:400px; margin-top:10px;" id="frame-count-display"></div>
                <div class="row-fluid" style="width:400px">
                    <div class=" col-xs-8">
                        <label style="color:white; font-weight:100;">Select framerate</label> <select id="frame-rate" class="form-control" style="width:auto;display:inline;">
                            <option value="6">6 fps</option>
                            <option value="12">12 fps</option>
                            <option value="24">24 fps</option>
                        </select>
                    </div>
                    <button id="btn-undo" class="btn btn-danger col-xs-4" style="vertical-align:bottom;">Undo</button>
                </div>
            </div>
        </div>
        <br /><br />
        <div class="row-fluid">
            <div class="col-xs-8" style="text-align:center;">
                <video id="output" controls="controls" width="400" height="300"></video>
                <div class="col-xs-4">
                    <a href="#" download="myAnimation.webm" id="export-link" class="btn btn-success btn-lg">Save As</a>
                </div>
            </div>

        </div>


    </div>






    <ul id="messages"></ul>
    <script src="webworker/RecordRTC.js?seed=1"></script>
    <script src="scripts/rx.lite.min.js"></script>
    <script>
        "use strict";
        // load webservice
        var Observable = Rx.Observable;
        var Subject = Rx.Subject;

        function log(message) {
            var messages = document.getElementById('messages');
            var m = document.createElement('li');
            m.innerHTML = JSON.stringify(message.data);
            messages.appendChild(m);
        }

        function leadingZero(number) {
            //if (number < 10) return '0000' + number.toString();
            //if (number < 100) return '000' + number.toString();
            //if (number < 1000) return '00' + number.toString();
            //if (number < 10000) return '0' + number.toString();
            return number.toString();
        }
        function format(str, replacements) {
            return str.replace(/\{([0-9]{1,3})\}/g, function (a, b) { return replacements[b]; });
        }

        function getEl(selector) {
            return document.querySelector(selector);
        }

        function draw(frame, info) {
            // Display position in process
            getEl('#frame-count-display').innerText = format("{2} Frame {0} of {1} @ {3} fps duration {4}s", [info.index + 1, info.length, info.exporting, info.frameRate, Math.round(100 * (info.length / info.frameRate)) / 100]);
            // Create image from Blob and draw to canvas
            var img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0, img.width, img.height);
            }
            img.src = URL.createObjectURL(frame.data);
        }

        /*  Set up camera */
        function useWebCamStream(stream) {
            var video = document.getElementById('video');
            let videoStream = stream;
            console.info('Connecting: ', stream.getVideoTracks()[0].label);
            if (video.mozSrcObject !== undefined) { //FF18a
                video.mozSrcObject = stream;
            } else {
                video.src = window.URL.createObjectURL(stream);
            }
            video.onloadedmetadata = function () {
            }
        }
        navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then(useWebCamStream);

        /* Get Elements */


        var canvas = document.getElementById('previewCanvas');
        var ctx = canvas.getContext('2d');
        var previewImage = document.getElementById('previewImage');


        /* REGISTER STREAMS */
        /* - INPUTS */
        var singlePlay$ = new Subject(); // set to fasle to pause on frame 1, set to true to play through once, set top null to loop
        var currentFrame$ = new Subject(); // set to frame to display zero index in array
        // handle clicks from the sutter
        // To Do: use merge to set-up to work as Time lapse function
        var shutterClick$ = Observable.fromEvent(getEl('#btn-shutter'), 'click');//.merge(Observable.timer(1500, 300)).take(130);
        // handle export requests
        var exportClick$ = Observable.fromEvent(getEl('#btn-export'), 'click');
        // undo -> deletes last frame
        var undoClick$ = Observable.fromEvent(getEl('#btn-undo'), 'click').filter(x => confirm('Are you sure you want to delete the last frame?'));
        // handle frame rate change requests
        var frameRate$ = Observable.fromEvent(getEl('#frame-rate'), 'change').map(x => parseInt(x.target.value)).startWith(6);
        // grab image from camera, turn to blob, and concatenate array in scan function
        var frames$ = shutterClick$.flatMapLatest(function captchaFrame(e) {
            //canvas = null;
            var _video = document.getElementById('video');
            return Observable.fromPromise(new Promise(function (fulfill, reject) {
                var video = _video;
                var w = video.videoWidth;
                var h = video.videoHeight;
                var videoAspect = w / h;
                var canvas;
                canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                var cxt = canvas.getContext('2d');
                cxt.drawImage(video, 0, 0, w, h);
                canvas.toBlob(function (blob) {
                    fulfill(blob);
                }, 'image/jpeg', 0.7);
            }));
        }).merge(undoClick$.map(null)).scan(function (frames, blob) {
            if (blob === null) {
                // delete last frame
                frames.pop();
                // load new last frame into overlay image
                if (frames.length > 0) document.querySelector('#image').src = URL.createObjectURL(frames[frames.length - 1].data);
            } else {
                // load frame into last frame overlay image
                document.querySelector('#image').src = URL.createObjectURL(blob);
                if (blob) frames.push({ name: format('image_{0}.jpg', [leadingZero(frames.length)]), data: blob });
            }
            return frames;
        }, []).share(); // share() forces above to only happen once no matter haw many subscribers stream has

        // collect all status streams for displaying animation
        var refreshPreview$ = Observable.timer(100, 1000 / 24, 10)
                        .withLatestFrom(frameRate$, frames$, singlePlay$.startWith(null), currentFrame$.startWith(0))
                        // limit refreshes based on framerate
                        // timer runs at 24 fps => gets  (24 / framerate) gets the number of frames to skip
                        // where x[0] is the total number of intervals collected
                        .filter(x => x[0] % (24 / x[1]) === 0)
                        // map to readable object
                       .map(x => { return { frameRate: x[1], frames: x[2], singlePlay: x[3], currentFrame: x[4] } });

        // on export button clicks send frame stream - map to duration in seconds frames count  / framerate
        var export$ = exportClick$.withLatestFrom(frames$, frameRate$).map(x => x[1].length / x[2]);
        var animationEnd$ = new Subject();
        /* SUBSCRIPTIONS */
        var recorder
        function exporting(duration) {
            recorder  = RecordRTC(canvas, {
                type: 'canvas'
            });
            currentFrame$.onNext(0);
            singlePlay$.onNext(true);

            recorder.startRecording();

            var stop = false;

            //setTimeout(() => recorder.stopRecording(function () {
            //    var blob = recorder.getBlob();
            //    document.getElementById('output').src = URL.createObjectURL(blob);
            //    document.getElementById('export-link').href = URL.createObjectURL(blob);
            //    singlePlay$.onNext(null);
            //}), duration * 1000);
        }

        animationEnd$.subscribe(function () {
            recorder.stopRecording(function () {
                var blob = recorder.getBlob();
                document.getElementById('output').src = URL.createObjectURL(blob);
                document.getElementById('export-link').href = URL.createObjectURL(blob);
                singlePlay$.onNext(null);
            });
        });

        // Select the frame to draw and send to draw function

        function nextFrame(obj) {
            var _frameRate = obj.frameRate;
            var _frames = obj.frames;
            var _singlePlay = obj.singlePlay;

            var i = obj.currentFrame;
            // loop
            if (_singlePlay === null) {
                if (_frames[i]) draw(_frames[i], { index: i, length: _frames.length, exporting: '', frameRate: _frameRate });
                if (i > _frames.length) {
                    currentFrame$.onNext(0);
                } else {
                    currentFrame$.onNext(obj.currentFrame + 1);
                }
            } else { // single play
                if (_singlePlay === true) { // play once
                    if (_frames[i]) {
                        draw(_frames[i], { index: i, length: _frames.length, exporting: 'Exporting', frameRate: _frameRate });
                        currentFrame$.onNext(obj.currentFrame + 1);
                    } else {
                        animationEnd$.onNext();
                    }
                } else { // pause at start
                    if (_frames[0]) draw(_frames[0], { index: 1, length: _frames.length, exporting: 'Exporting', frameRate: _frameRate });
                }
            }
        }

        refreshPreview$.subscribe(obj => { window.requestAnimationFrame(() => nextFrame(obj)) });

        export$.subscribe(exporting);







        /* WORKER */
        //var worker = new Worker(format('webworker/myWebWorker.js?seed={0}', [Math.floor(Math.random() * 1000)]));
        //var workerEvent$ = Observable.fromEvent(worker, 'message').map(x => x.data).share();
        //var workerReady$ = workerEvent$.filter(x => x.type === 'ready');
        //var workerStart$ = workerEvent$.filter(x => x.type === 'start');
        //var workerStdout$ = workerEvent$.filter(x => x.type === 'stdout');
        //var workerDone$ = workerEvent$.filter(x => x.type === 'done');
        //var video$ = workerDone$.map(function (x) { console.log(x); return x.data[0]; });

        /* WORKER */
        //workerReady$.subscribe(function () { });

        //workerStart$.subscribe(log);
        //workerEvent$.subscribe(log);

        //video$.subscribe(function (result) {
        //    var blob;
        //    if (result) blob = new Blob([result.data], { type: 'video/mp4' });
        //});

        /* ****** */

        //var out = new Blob();
        //worker.postMessage({
        //    type: 'command',
        //    arguments: [
        //       '-i', 'image_%d.jpg',
        //       '-f', 'image2',
        //        '-r', '24',
        //        '-c:v', 'mpeg4',
        //        '-b:v', '600k',
        //     //   '-analyzeduration', '50',
        //     //   '-probesize', '20',
        //     //   '-strict', 'experimental',
        //        '-y',
        //        '-stats',
        //        'output2.mp4'
        //    ],
        //    //files: ['test.mp4', new Uint8Array(e)]
        //    files: frames
        //});





    </script>
</body>
</html>
